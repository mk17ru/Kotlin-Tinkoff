# Kotlin course
## [Lesson2](https://github.com/mk17ru/Kotlin-Tinkoff/tree/main/lessson2)
### OOP
Выбрать предметную область(только не "животные" и не "студенты/преподаватели").<br />
Описать не менее 3-х классов, имеющих общего предка в виде абстрактного класса или реализующие общий интерфейс. Классы должны иметь свойства, в том числе и private, иметь<br /> перегруженные методы(достаточно выполнить перегрузку в 1 классе), реализовывать абстрактный метод интерфейса или метод абстрактного класса, каждый класс должен иметь общий со<br /> своим супертипом и уникальный функционалы(в виде свойств и методов).<br />
Создать точку входа в виде консольного приложения с функцией main.<br />
В функции main создать экземпляры объектов всех классов, продемонстрировать работу с общим функционалом, используя ссылку на супер-класс или интерфейсную ссылку.<br /> Продемонстрировать работу функционала, характерного только для конкретного класса.<br />
## [Lesson3](https://github.com/mk17ru/Kotlin-Tinkoff/tree/main/lesson3) 
### Collections Part1
Реализовать стеки и очереди на Котлин.<br />
<br />
Требования для очередей:<br />
<br />
реализовать метод enqueue, добавляющий элемент в конец очереди<br />
реализовать метод dequeue, возвращающий первый элемент очереди и удаляющий его из коллекции.<br />
Опционально: сделать DSL по примеру существующих(например, listOf())<br />
Требования для стеков:<br />
<br />
реализовать метод push, добавляющий элемент в стек.<br />
реализовать метод pop, возвращающий верхний элемент и удаляющий его из коллекции<br />
Опционально: сделать DSL по примеру существующих(например, listOf())<br />
## [Lesson4](https://github.com/mk17ru/Kotlin-Tinkoff/tree/main/lesson4) 
### Collections Part 2
Выбрать предметную область<br />
Создать два класса данных, не менее 3х полей у каждого. <br />
Одно из полей должно каким-то образов связывать эти классы( как ключи в БД) - пример ниже<br />
Создать два источника данных, имитирующих DAO - по факту просто два класса с заранее заполненными неизменяемыми списками объектов из п2. Каждый из них должен иметь методы,<br /> возвращающие всю коллекцию целиком, один из них - дополнительно иметь метод, возвращающий элемент коллекции по тому полю, которое объединяет оба класса данных.<br />
Создать третий класс данных, объединяющий поля классов из п.2<br />
Создать класс-сервис, реализующий следующие методы:<br />
Метод, собирающий данные из первого класса-источника, и преобразовывающий их в список элементов класса из п4 с использованием данных, полученных из второго класса источника<br />
Метод, возвращающий отсортированный по какому-либо полю список из пункта 5а<br />
Метод, группирующий элементы списка из 5а по какому-либо заранее выбранному полю<br />
Метод, возвращающий количество элементов списка из 5а соответствующих переданному условию, должен принимать на вход предикат.<br />
<br />
Пример классов данных:<br />
<br />
data class User(val id: Int, val name: String)<br />
data class UserFriends(val userId: Int, val friendsIds: List<Int>)<br />
<br />
data class UserWithFriend(val id: Int, val name: String, val friendsIds: List<Int>)<br />
## [Lesson5](https://github.com/mk17ru/Kotlin-Tinkoff/tree/main/lesson5) 
### DataBases
  Выбрать предметную область (можно такую же как и в 4 задание, по коллекция )\
Создать три класса данных, не менее 3х полей у каждого. Одно из полей должно каким-то образов связывать эти классы.\
Реализовать в этих классах связку один ко многим и многие-ко-многим (для этого понадобится еще 1 класс( таблица в БД) )\
На основе DAO классов созданных выше, написать sql скрипты для создание таблиц в БД/
Реализовать в приложение следующие сервисы:\
Класс - клиент, который будет отвечать за подключение к БД. Всю информацию по подключению можно хранить как внутри класса, так и передавать в его конструктор например. Внутри класса можно реализовать методы подключения к БД, обработки каких либо sql запросов.\
Класс инициализации (создания исходных таблиц) и удаление этих таблиц. На основе скриптов п.4 можно создать класс, который будет содержать скрипты по созданию и удалению таблиц (реализацию данного класса можно изменить по своему усмотрению)\
Класс сервис, который должен содержать методы получения данных из БД по какой-либо логике. Он внутри себя должен обращаться к классу Клиенту 5a, передавать запрос в него и потом обрабатывать ответ самостоятельно. Необходимо реализовать логику, которая будет описана в п.6
Логика выборки данных из таблиц:\
Найти 1 значению в таблице по id (идентификатору)\
Найти все элементы в таблице которые имеют идентификатор > 2 (или какое нить другое поле, и условие на ваш выбор)\
Сделать выборку из связанных таблиц (операторы JOIN, LEFT JOIN) (Возможно при маппинге из ResultSet понадобится новая сущность (необходимо будет создать))\
Сделать выборку с группировкой по какому нибудь полю\
Сделать выборку и отсортировать в порядке убывания значений.\
Все операции надо реализовать через SQL, а не обрабатывать результат уже после получения. Результат необходимо вывести в консоль приложения.\
\
Если по какой то причине при работе с БД произошла ошибка (неправильный синтаксис SQL выражения), ее необходимо обработать и вывести соотетствующее сообщение, при это программа должна продолжить работу а не упасть. (Для обработки исключения, можно создать свое собственное исключение.)\
## [Lesson6](https://github.com/mk17ru/Kotlin-Tinkoff/tree/main/lesson6) 
Tests
## [Lesson7](https://github.com/mk17ru/Kotlin-Tinkoff/tree/main/lesson7) 
### Concurrency
## [Lesson8]() 
### Coroutines // Pull request
## [Lesson9]()
### Http // Pull request
## [Lesson10]()
### Ktor // Pull request
## [Lesson11]()
### Queues // Pull request
## [Lesson12]()
### Kotlin-DSL // Pull request
## [Lesson13]()
### Docker // Pull request
