# Kotlin course
## [Lesson2](https://github.com/mk17ru/Kotlin-Tinkoff/tree/main/lessson2)
### OOP
Выбрать предметную область(только не "животные" и не "студенты/преподаватели").<br />
Описать не менее 3-х классов, имеющих общего предка в виде абстрактного класса или реализующие общий интерфейс. Классы должны иметь свойства, в том числе и private, иметь<br /> перегруженные методы(достаточно выполнить перегрузку в 1 классе), реализовывать абстрактный метод интерфейса или метод абстрактного класса, каждый класс должен иметь общий со<br /> своим супертипом и уникальный функционалы(в виде свойств и методов).<br />
Создать точку входа в виде консольного приложения с функцией main.<br />
В функции main создать экземпляры объектов всех классов, продемонстрировать работу с общим функционалом, используя ссылку на супер-класс или интерфейсную ссылку.<br /> Продемонстрировать работу функционала, характерного только для конкретного класса.<br />
## [Lesson3](https://github.com/mk17ru/Kotlin-Tinkoff/tree/main/lesson3) 
### Collections Part1
Реализовать стеки и очереди на Котлин.<br />
<br />
Требования для очередей:<br />
<br />
реализовать метод enqueue, добавляющий элемент в конец очереди<br />
реализовать метод dequeue, возвращающий первый элемент очереди и удаляющий его из коллекции.<br />
Опционально: сделать DSL по примеру существующих(например, listOf())<br />
Требования для стеков:<br />
<br />
реализовать метод push, добавляющий элемент в стек.<br />
реализовать метод pop, возвращающий верхний элемент и удаляющий его из коллекции<br />
Опционально: сделать DSL по примеру существующих(например, listOf())<br />
## [Lesson4](https://github.com/mk17ru/Kotlin-Tinkoff/tree/main/lesson4) 
### Collections Part 2
Выбрать предметную область<br />
Создать два класса данных, не менее 3х полей у каждого. <br />
Одно из полей должно каким-то образов связывать эти классы( как ключи в БД) - пример ниже<br />
Создать два источника данных, имитирующих DAO - по факту просто два класса с заранее заполненными неизменяемыми списками объектов из п2. Каждый из них должен иметь методы,<br /> возвращающие всю коллекцию целиком, один из них - дополнительно иметь метод, возвращающий элемент коллекции по тому полю, которое объединяет оба класса данных.<br />
Создать третий класс данных, объединяющий поля классов из п.2<br />
Создать класс-сервис, реализующий следующие методы:<br />
Метод, собирающий данные из первого класса-источника, и преобразовывающий их в список элементов класса из п4 с использованием данных, полученных из второго класса источника<br />
Метод, возвращающий отсортированный по какому-либо полю список из пункта 5а<br />
Метод, группирующий элементы списка из 5а по какому-либо заранее выбранному полю<br />
Метод, возвращающий количество элементов списка из 5а соответствующих переданному условию, должен принимать на вход предикат.<br />
<br />
Пример классов данных:<br />
<br />
data class User(val id: Int, val name: String)<br />
data class UserFriends(val userId: Int, val friendsIds: List<Int>)<br />
<br />
data class UserWithFriend(val id: Int, val name: String, val friendsIds: List<Int>)<br />
## [Lesson5](https://github.com/mk17ru/Kotlin-Tinkoff/tree/main/lesson5) 
DataBases
## [Lesson6](https://github.com/mk17ru/Kotlin-Tinkoff/tree/main/lesson6) 
Tests
## [Lesson7](https://github.com/mk17ru/Kotlin-Tinkoff/tree/main/lesson7) 
Concurrency
## [Lesson8]() 
Coroutines // Pull request
## [Lesson9]()
Http // Pull request
## [Lesson10]()
Ktor // TODO
## [Lesson11]()
Queues // TODO
## [Lesson12]()
Kotlin-DSL // TODO
## [Lesson13]()
Docker // TODO
